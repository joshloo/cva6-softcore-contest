
/*******************************************************************************
    Verilog netlist generated by IPGEN Lattice Propel (64-bit)
    2024.1.2406150513_p
    Soft IP Version: 1.0.0
    2024 08 24 00:01:17
*******************************************************************************/
/*******************************************************************************
    Wrapper Module generated per user settings.
*******************************************************************************/
(* ORIG_MODULE_NAME="mbconfig0", LATTICE_IP_GENERATED="1" *) module mbconfig0 (pclk_i, 
        rstn_i, 
        apb_penable_i, 
        apb_psel_i, 
        apb_pwrite_i, 
        apb_paddr_i, 
        apb_pwdata_i, 
        apb_pready_o, 
        apb_pslverr_o, 
        apb_prdata_o, 
        config_active) ;
    input pclk_i ; 
    input rstn_i ; 
    input apb_penable_i ; 
    input apb_psel_i ; 
    input apb_pwrite_i ; 
    input [31:0] apb_paddr_i ; 
    input [31:0] apb_pwdata_i ; 
    output apb_pready_o ; 
    output apb_pslverr_o ; 
    output [31:0] apb_prdata_o ; 
    output config_active ; 
    parameter SIM = 0 ; 
    mbconfig0_ipgen_fpga_multiboot_config #(.SIM(SIM)) fpga_multiboot_config_inst (.pclk_i(pclk_i), 
                .rstn_i(rstn_i), 
                .apb_penable_i(apb_penable_i), 
                .apb_psel_i(apb_psel_i), 
                .apb_pwrite_i(apb_pwrite_i), 
                .apb_paddr_i(apb_paddr_i[31:0]), 
                .apb_pwdata_i(apb_pwdata_i[31:0]), 
                .apb_pready_o(apb_pready_o), 
                .apb_pslverr_o(apb_pslverr_o), 
                .apb_prdata_o(apb_prdata_o[31:0]), 
                .config_active(config_active)) ; 
endmodule



module mbconfig0_ipgen_fpga_multiboot_config #(parameter SIM = 1) (
    input pclk_i, 
    input rstn_i, 
    input [31:0] apb_paddr_i, 
    input apb_psel_i, 
    input apb_penable_i, 
    input apb_pwrite_i, 
    input [31:0] apb_pwdata_i, 
    output apb_pready_o, 
    output reg [31:0] apb_prdata_o, 
    output apb_pslverr_o, 
    output wire config_active) ;
    wire soft_config_en_o_wire ; 
    // Parameter
    parameter REG_WIDTH = 32 ; 
    // Register
    reg [(REG_WIDTH - 1):0] reg_data ; 
    // Address decoding
    reg reg_addr ; 
    // Sequential logic
    always
        @(posedge pclk_i or 
            negedge rstn_i)
        begin
            if ((!rstn_i)) 
                begin
                    // Reset
                    reg_data <=  0 ;
                end
            else
                if ((((apb_psel_i && apb_penable_i) && apb_pwrite_i) && (apb_paddr_i[2] == 1'b0))) 
                    begin
                        // Write operation
                        reg_data <=  apb_pwdata_i ;
                    end
        end
    // Output data handling
    always
        @(*)
        begin
            if ((((apb_psel_i && apb_penable_i) && (!apb_pwrite_i)) && (reg_addr == 1'b0))) 
                begin
                    // Read operation
                    apb_prdata_o = reg_data ;
                end
            else
                begin
                    apb_prdata_o = 32'hzzzzzzzz ;// Output data if read operation
                end
        end
    // Address decoding
    always
        @(*)
        begin
            reg_addr = apb_paddr_i[2] ;// Using bit [2] for address decoding
        end
    // pslverr signal
    assign apb_pslverr_o = ((apb_psel_i && apb_penable_i) && (apb_paddr_i[2] != 1'b0)) ; // Set to 1 when accessing invalid address
    // pready signal
    assign apb_pready_o = (apb_psel_i && apb_penable_i) ; // Set to 1 when slave is selected and enabled
    // Output dependent on the 0th bit of reg_data
    assign soft_config_en_o_wire = reg_data[0] ; 
    (* syn_preserve=1 *) reg lmmi_request ; 
    (* syn_preserve=1 *) reg lmmi_wr_rdn ; 
    (* syn_preserve=1 *) reg [15:0] lmmi_wdata ; 
    (* syn_preserve=1 *) reg [7:0] lmmi_offset ; 
    (* syn_preserve=1 *) wire [15:0] lmmi_rdata_o ; 
    (* syn_preserve=1 *) wire lmmi_rdata_valid_o ; 
    (* syn_preserve=1 *) wire lmmi_ready_o ; 
    (* syn_preserve=1 *) reg start_i_d ; 
    (* syn_preserve=1 *) reg start_i_dd ; 
    (* syn_preserve=1 *) reg config_done_o_reg ; 
    parameter LMMI_IDLE0 = 4'b0000 ; 
    parameter LMMI_IDLE1 = 4'b0001 ; 
    parameter LMMI_WRITE_0 = 4'b0010 ; 
    parameter LMMI_WRITE_1 = 4'b0011 ; 
    parameter LMMI_DEASSERT_REQUEST = 4'b0100 ; 
    parameter LMMI_EXIT = 4'b0101 ; 
    (* syn_preserve=1 *) reg [3:0] state = LMMI_IDLE0 ; 
    assign config_active = config_done_o_reg ; 
    always
        @(posedge pclk_i or 
            negedge rstn_i)
        begin
            if ((!rstn_i)) 
                begin
                    state <=  LMMI_IDLE0 ;
                    lmmi_request <=  1'b0 ;
                    lmmi_wr_rdn <=  1'b0 ;
                    lmmi_wdata <=  16'h0000 ;
                    lmmi_offset <=  8'h00 ;
                    start_i_d <=  1'b0 ;
                    start_i_dd <=  1'b0 ;
                    config_done_o_reg <=  1'b0 ;
                end
            else
                begin
                    start_i_d <=  soft_config_en_o_wire ;
                    start_i_dd <=  start_i_d ;
                    case (state)
                    LMMI_IDLE0 : 
                        begin
                            lmmi_offset <=  8'h00 ;
                            lmmi_request <=  1'b0 ;
                            lmmi_wr_rdn <=  1'b0 ;
                            lmmi_wdata <=  16'h0000 ;
                            if (((start_i_dd == 1'b0) && (start_i_d == 1'b1))) 
                                begin
                                    state <=  LMMI_IDLE1 ;
                                    config_done_o_reg <=  1'b0 ;
                                end
                        end
                    LMMI_IDLE1 : 
                        begin
                            config_done_o_reg <=  1'b0 ;
                            lmmi_offset <=  8'h00 ;
                            lmmi_request <=  1'b0 ;
                            lmmi_wr_rdn <=  1'b0 ;
                            lmmi_wdata <=  16'h0000 ;
                            state <=  LMMI_WRITE_0 ;
                        end
                    LMMI_WRITE_0 : 
                        begin
                            config_done_o_reg <=  1'b0 ;
                            lmmi_offset <=  8'h00 ;
                            lmmi_request <=  1'b1 ;
                            lmmi_wr_rdn <=  1'b1 ;
                            lmmi_wdata <=  16'h8000 ;
                            if (lmmi_ready_o) 
                                begin
                                    state <=  LMMI_WRITE_1 ;
                                end
                        end
                    LMMI_WRITE_1 : 
                        begin
                            config_done_o_reg <=  1'b0 ;
                            lmmi_offset <=  8'h00 ;
                            lmmi_request <=  1'b1 ;
                            lmmi_wr_rdn <=  1'b1 ;
                            lmmi_wdata <=  16'h0A00 ;
                            if (lmmi_ready_o) 
                                begin
                                    state <=  LMMI_DEASSERT_REQUEST ;
                                end
                        end
                    LMMI_DEASSERT_REQUEST : 
                        begin
                            config_done_o_reg <=  1'b1 ;
                            lmmi_offset <=  8'h00 ;
                            lmmi_request <=  1'b0 ;
                            lmmi_wr_rdn <=  1'b0 ;
                            lmmi_wdata <=  16'h0000 ;
                            if ((lmmi_ready_o & (!lmmi_rdata_valid_o))) 
                                begin
                                    state <=  LMMI_EXIT ;
                                end
                        end
                    LMMI_EXIT : 
                        begin
                            config_done_o_reg <=  1'b1 ;
                            lmmi_offset <=  8'h00 ;
                            lmmi_request <=  1'b0 ;
                            lmmi_wr_rdn <=  1'b0 ;
                            lmmi_wdata <=  16'h0000 ;
                            state <=  LMMI_IDLE0 ;
                        end
                    default : 
                        begin
                            config_done_o_reg <=  1'b0 ;
                            lmmi_offset <=  8'h00 ;
                            lmmi_request <=  1'b0 ;
                            lmmi_wr_rdn <=  1'b0 ;
                            lmmi_wdata <=  16'h0000 ;
                            state <=  LMMI_IDLE0 ;
                        end
                    endcase 
                end
        end
    CONFIG_LMMIC CONFIG_LMMIC_inst (.LMMICLK(pclk_i),  // I
            .LMMIRESET_N(rstn_i),  // I
            .LMMIREQUEST(lmmi_request),  // I
            .LMMIWRRDN(lmmi_wr_rdn),  // I
            .LMMIOFFSET(lmmi_offset),  // I
            .LMMIWDATA(lmmi_wdata[15:0]),  // I
            .LMMIRDATA(lmmi_rdata_o[15:0]),  // O
            .LMMIRDATAVALID(lmmi_rdata_valid_o),  // O
            .LMMIREADY(lmmi_ready_o) // O
            ) ; 
endmodule


