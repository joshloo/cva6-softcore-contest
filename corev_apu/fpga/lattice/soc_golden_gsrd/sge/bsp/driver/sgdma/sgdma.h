/*   ==================================================================

     >>>>>>>>>>>>>>>>>>>>>>> COPYRIGHT NOTICE <<<<<<<<<<<<<<<<<<<<<<<<<
     ------------------------------------------------------------------
     Copyright (c) 2019-2024 by Lattice Semiconductor Corporation
     ALL RIGHTS RESERVED
     ------------------------------------------------------------------

       IMPORTANT: THIS FILE IS USED BY OR GENERATED BY the LATTICE PROPELâ„¢
       DEVELOPMENT SUITE, WHICH INCLUDES PROPEL BUILDER AND PROPEL SDK.

       Lattice grants permission to use this code pursuant to the
       terms of the Lattice Propel License Agreement.

     DISCLAIMER:

    LATTICE MAKES NO WARRANTIES ON THIS FILE OR ITS CONTENTS,
    WHETHER EXPRESSED, IMPLIED, STATUTORY,
    OR IN ANY PROVISION OF THE LATTICE PROPEL LICENSE AGREEMENT OR
    COMMUNICATION WITH LICENSEE,
    AND LATTICE SPECIFICALLY DISCLAIMS ANY IMPLIED WARRANTY OF
    MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.
    LATTICE DOES NOT WARRANT THAT THE FUNCTIONS CONTAINED HEREIN WILL MEET
    LICENSEE 'S REQUIREMENTS, OR THAT LICENSEE' S OPERATION OF ANY DEVICE,
    SOFTWARE OR SYSTEM USING THIS FILE OR ITS CONTENTS WILL BE
    UNINTERRUPTED OR ERROR FREE,
    OR THAT DEFECTS HEREIN WILL BE CORRECTED.
    LICENSEE ASSUMES RESPONSIBILITY FOR SELECTION OF MATERIALS TO ACHIEVE
    ITS INTENDED RESULTS, AND FOR THE PROPER INSTALLATION, USE,
    AND RESULTS OBTAINED THEREFROM.
    LICENSEE ASSUMES THE ENTIRE RISK OF THE FILE AND ITS CONTENTS PROVING
    DEFECTIVE OR FAILING TO PERFORM PROPERLY AND IN SUCH EVENT,
    LICENSEE SHALL ASSUME THE ENTIRE COST AND RISK OF ANY REPAIR, SERVICE,
    CORRECTION,
    OR ANY OTHER LIABILITIES OR DAMAGES CAUSED BY OR ASSOCIATED WITH THE
    SOFTWARE.IN NO EVENT SHALL LATTICE BE LIABLE TO ANY PARTY FOR DIRECT,
    INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES,
    INCLUDING LOST PROFITS,
    ARISING OUT OF THE USE OF THIS FILE OR ITS CONTENTS,
    EVEN IF LATTICE HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.
    LATTICE 'S SOLE LIABILITY, AND LICENSEE' S SOLE REMEDY,
    IS SET FORTH ABOVE.
    LATTICE DOES NOT WARRANT OR REPRESENT THAT THIS FILE,
    ITS CONTENTS OR USE THEREOF DOES NOT INFRINGE ON THIRD PARTIES'
    INTELLECTUAL PROPERTY RIGHTS, INCLUDING ANY PATENT. IT IS THE USER' S
    RESPONSIBILITY TO VERIFY THE USER SOFTWARE DESIGN FOR CONSISTENCY AND
    FUNCTIONALITY THROUGH THE USE OF FORMAL SOFTWARE VALIDATION METHODS.
     ------------------------------------------------------------------

     ================================================================== */
#ifndef SGDMA_H_
#define SGDMA_H_

#include <stdbool.h>

/* Sgdma driver source code versions */
#define SGDMA_DRV_VER "v2024.01.00"

/* Register name, address and offset */
#define MM2S_CTRL					(0x00U)
#define MM2S_STS					(0x04U)
#define MM2S_CURDESC				(0x08U)
#define S2MM_CTRL					(0x20U)
#define S2MM_STS					(0x24U)
#define S2MM_CURDESC				(0x28U)
#define MAX_TRANSFER_SIZE			(0xffffU)
#define FP_BIT_POSITION				(30U)
#define NXT_BIT_POSITION			(31U)
#define TID_BIT_POSITION			(20U)
#define TDEST_BIT_POSITION			(16U)
#define XFER_CMPL_POSITION			(16U)
#define BUFFER_SIZE_MASK			(0xffffU)
#define SGDMA_RESET					(1U)
#define DMA_TRIGGER					(1U)
#define DESC_NEXT                   (1U)
#define DESC_LAST                   (0U)
#define FP_1						(1U)
#define FP_0						(0U)
#define XFER_CMPL_1					(0x01U)
#define SUCCESS                     (1U)
#define FAILURE                     (0U)

#define IS_NULL						(0)

/*Enum*/
typedef enum
{
	MM2S_CONTROL = 0,
	S2MM_CONTROL = 0x20,
}control_type_t;

typedef enum
{
	MM2S_STATUS = 0x04,
	S2MM_STATUS = 0x24,
}status_type_t;

typedef enum
{
	UNMASK = 0,
	MASK,
}irq_mask_t;

typedef enum
{
	MM2S_CTRL_REG = 0,
	MM2S_STATUS_REG = 0x04,
	MM2S_CURDESC_REG = 0x08,
	S2MM_CTRL_REG = 0x20,
	S2MM_STATUS_REG = 0x24,
	S2MM_CURDESC_REG = 0x28,
}sgdma_reg_type_t;

/*------------------------------------------- structure and union ------------------------------------------------------*/
/*mm2s control and status register structure */
typedef struct {
	volatile unsigned int mm_request : 1;
	volatile unsigned int mm_reset : 1;
	volatile unsigned int mm_rsvd_1 : 14;
	volatile unsigned int mm_cmpl_irq_mask : 1;
	volatile unsigned int mm_rsvd_2 : 15;
}mm2s_ctrl_reg_t;

typedef struct {
	volatile unsigned int mm_status : 1;
	volatile unsigned int mm_rsvd_1 : 7;
	volatile unsigned int mm_reg_bd_len_err : 1;
	volatile unsigned int mm_reg_axi_slave_err : 1;
	volatile unsigned int mm_reg_axi_desc_err : 1;
	volatile unsigned int mm_rsvd_2 : 5;
	volatile unsigned int mm_xfer_cmpl : 1;
	volatile unsigned int mm_xfer_err : 1;
	volatile unsigned int mm_rsvd_3 : 14;
}mm2s_sts_reg_t;

/* mm2s single and multi buffer Descriptor Structure */
typedef struct {
	volatile unsigned int mm_buffer_addr;	//Buffer addr
	volatile unsigned int mm_buffer_msb_addr;	//Buffer msb addr
	volatile unsigned int mm_control_buffer_size : 16;	//Control
	volatile unsigned int mm_control_tdest : 4;
	volatile unsigned int mm_control_tid : 4;
	volatile unsigned int mm_control_arprot : 3;
	volatile unsigned int mm_control_rsvd : 3;
	volatile unsigned int mm_control_fp : 1;
	volatile unsigned int mm_control_nxt : 1;
	volatile unsigned int mm_status_transffered_size : 16;	//Status
	volatile unsigned int mm_status_rsvd : 11;
	volatile unsigned int mm_status_axi_desc_err : 1;
	volatile unsigned int mm_status_axi_slave_err : 1;
	volatile unsigned int mm_status_transffered_len_err : 1;
	volatile unsigned int mm_status_bd_len_err : 1;
	volatile unsigned int mm_status_cmpl : 1;
}mm2s_desc_tx_t;

typedef struct{
	volatile unsigned int mm_buffer_addr;
	volatile unsigned int mm_buffer_msb_addr;
	volatile unsigned int mm_control;
	volatile unsigned int mm_status;
}mm2s_desc_tx_ext_t;

/*mm2s  union*/
typedef union
{
	mm2s_desc_tx_ext_t mm_bd_ext;
	mm2s_desc_tx_t mm_bd;
}mm2s_desc_t;

/* s2mm control and status register structure */
typedef struct {
	volatile unsigned int s_request : 1;
	volatile unsigned int s_reset : 1;
	volatile unsigned int s_rsvd_1 : 14;
	volatile unsigned int s_cmpl_irq_mask : 1;
	volatile unsigned int s_rsvd_2 : 15;
}s2mm_ctrl_reg_t;

typedef struct {
	volatile unsigned int s_status : 1;
	volatile unsigned int s_rsvd_1 : 7;
	volatile unsigned int s_reg_bd_len_err : 1;
	volatile unsigned int s_reg_axi_slave_err : 1;
	volatile unsigned int s_reg_axi_desc_err : 1;
	volatile unsigned int s_rsvd_2 : 5;
	volatile unsigned int s_xfer_cmpl : 1;
	volatile unsigned int s_xfer_err : 1;
	volatile unsigned int s_rsvd_3 : 14;
}s2mm_sts_reg_t;

/*s2mm single and multi buffer Descriptor Structure */
typedef struct {
	volatile unsigned int s_buffer_addr;	//Buffer addr
	volatile unsigned int s_buffer_msb_addr;	//Buffer msb addr
	volatile unsigned int s_control_buffer_size : 16;	//Control
	volatile unsigned int s_control_rsvd_1 : 8;
	volatile unsigned int s_control_awprot : 3;
	volatile unsigned int s_control_rsvd_2 : 4;
	volatile unsigned int s_control_nxt : 1;
	volatile unsigned int s_status_transffered_size : 16;	//Status
	volatile unsigned int s_status_rsvd : 11;
	volatile unsigned int s_status_axi_desc_err : 1;
	volatile unsigned int s_status_axi_slave_err : 1;
	volatile unsigned int s_status_transffered_len_err : 1;
	volatile unsigned int s_status_bd_len_err : 1;
	volatile unsigned int s_status_cmpl : 1;
}s2mm_desc_tx_t;

typedef struct{
	volatile unsigned int s_buffer_addr;
	volatile unsigned int s_buffer_msb_addr;
	volatile unsigned int s_control;
	volatile unsigned int s_status;
}s2mm_desc_tx_ext_t;

/*s2mm union */
typedef union
{
	s2mm_desc_tx_ext_t s_bd_ext;
	s2mm_desc_tx_t s_bd;
}s2mm_desc_t;

typedef struct {
	volatile unsigned int request : 1;
	volatile unsigned int reset : 1;
	volatile unsigned int rsvd_1 : 14;
	volatile unsigned int cmpl_irq_mask : 1;
	volatile unsigned int rsvd_2 : 15;
}sgdma_ctrl_reg_t;

typedef struct {
	volatile unsigned int status : 1;
	volatile unsigned int rsvd_1 : 7;
	volatile unsigned int reg_bd_len_err : 1;
	volatile unsigned int reg_axi_slave_err : 1;
	volatile unsigned int reg_axi_desc_err : 1;
	volatile unsigned int rsvd_2 : 5;
	volatile unsigned int xfer_cmpl : 1;
	volatile unsigned int xfer_err : 1;
	volatile unsigned int rsvd_3 : 14;
}sgdma_sts_reg_t;


typedef struct {
	unsigned int base_addr;
	unsigned int *mm2s_buffer_address;
	unsigned int *s2mm_buffer_address;
    unsigned int axi4_mm_data_width;
	unsigned int num_of_mm2s_desc;
	unsigned int num_of_s2mm_desc;
    // If the user sets blocking_mm2s or blocking_s2mm, the system will continuously check the descriptor status until the operation is complete or an error occurs.
    // However, if the user does not intend to monitor the system closely, they should set both blocking_s2mm and blocking_mm2s to false.
    // Additionally, user can periodically call the mm2s_get_desc_complete_bit and s2mm_get_desc_complete_bit functions to avoid the system continuously polling for status.
	unsigned int blocking_s2mm;
	unsigned int blocking_mm2s;
	mm2s_desc_t *mm2s_bd_addr;
	s2mm_desc_t *s2mm_bd_addr;
	unsigned int *per_mm2s_desc_length;
	unsigned int *per_s2mm_desc_length;
    unsigned int fp;
}sgdma_instance_t;

/* --------------------------------------------------- Declaration ------------------------------------------------- */
void sgdma_init(sgdma_instance_t *this_sgdma, unsigned int base_addr);
void sgdma_reset(sgdma_instance_t *this_sgdma);
void sgdma_irq_mask(sgdma_instance_t *this_sgdma, control_type_t sgdma_cntl_type, irq_mask_t mask_value);
sgdma_sts_reg_t * get_sgdma_reg_status(sgdma_instance_t *this_sgdma, status_type_t sgdma_sts_type);
unsigned int get_mm2s_bd_status(int idx);
unsigned int get_s2mm_bd_status(int idx);
unsigned int mm2s_get_desc_complete_bit(sgdma_instance_t * this_sgdma, unsigned int idx, unsigned char * isComplete, unsigned char * isError);
unsigned int mm2s_buf_desc_dma(sgdma_instance_t *this_sgdma);
unsigned int s2mm_get_desc_complete_bit(sgdma_instance_t * this_sgdma, unsigned int idx, unsigned char * isComplete, unsigned char * isError);
unsigned int s2mm_buf_desc_dma(sgdma_instance_t *this_sgdma);
unsigned int sgdma_register_read(sgdma_instance_t *this_sgdma, sgdma_reg_type_t index, unsigned int *reg_data);
unsigned int sgdma_register_write(sgdma_instance_t *this_sgdma, sgdma_reg_type_t index, unsigned int reg_data);

#endif
