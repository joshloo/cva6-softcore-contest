/*   ==================================================================

     >>>>>>>>>>>>>>>>>>>>>>> COPYRIGHT NOTICE <<<<<<<<<<<<<<<<<<<<<<<<<
     ------------------------------------------------------------------
     Copyright (c) 2019-2024 by Lattice Semiconductor Corporation
     ALL RIGHTS RESERVED
     ------------------------------------------------------------------

       IMPORTANT: THIS FILE IS USED BY OR GENERATED BY the LATTICE PROPELâ„¢
       DEVELOPMENT SUITE, WHICH INCLUDES PROPEL BUILDER AND PROPEL SDK.

       Lattice grants permission to use this code pursuant to the
       terms of the Lattice Propel License Agreement.

     DISCLAIMER:

    LATTICE MAKES NO WARRANTIES ON THIS FILE OR ITS CONTENTS,
    WHETHER EXPRESSED, IMPLIED, STATUTORY,
    OR IN ANY PROVISION OF THE LATTICE PROPEL LICENSE AGREEMENT OR
    COMMUNICATION WITH LICENSEE,
    AND LATTICE SPECIFICALLY DISCLAIMS ANY IMPLIED WARRANTY OF
    MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.
    LATTICE DOES NOT WARRANT THAT THE FUNCTIONS CONTAINED HEREIN WILL MEET
    LICENSEE 'S REQUIREMENTS, OR THAT LICENSEE' S OPERATION OF ANY DEVICE,
    SOFTWARE OR SYSTEM USING THIS FILE OR ITS CONTENTS WILL BE
    UNINTERRUPTED OR ERROR FREE,
    OR THAT DEFECTS HEREIN WILL BE CORRECTED.
    LICENSEE ASSUMES RESPONSIBILITY FOR SELECTION OF MATERIALS TO ACHIEVE
    ITS INTENDED RESULTS, AND FOR THE PROPER INSTALLATION, USE,
    AND RESULTS OBTAINED THEREFROM.
    LICENSEE ASSUMES THE ENTIRE RISK OF THE FILE AND ITS CONTENTS PROVING
    DEFECTIVE OR FAILING TO PERFORM PROPERLY AND IN SUCH EVENT,
    LICENSEE SHALL ASSUME THE ENTIRE COST AND RISK OF ANY REPAIR, SERVICE,
    CORRECTION,
    OR ANY OTHER LIABILITIES OR DAMAGES CAUSED BY OR ASSOCIATED WITH THE
    SOFTWARE.IN NO EVENT SHALL LATTICE BE LIABLE TO ANY PARTY FOR DIRECT,
    INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES,
    INCLUDING LOST PROFITS,
    ARISING OUT OF THE USE OF THIS FILE OR ITS CONTENTS,
    EVEN IF LATTICE HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.
    LATTICE 'S SOLE LIABILITY, AND LICENSEE' S SOLE REMEDY,
    IS SET FORTH ABOVE.
    LATTICE DOES NOT WARRANT OR REPRESENT THAT THIS FILE,
    ITS CONTENTS OR USE THEREOF DOES NOT INFRINGE ON THIRD PARTIES'
    INTELLECTUAL PROPERTY RIGHTS, INCLUDING ANY PATENT. IT IS THE USER' S
    RESPONSIBILITY TO VERIFY THE USER SOFTWARE DESIGN FOR CONSISTENCY AND
    FUNCTIONALITY THROUGH THE USE OF FORMAL SOFTWARE VALIDATION METHODS.
     ------------------------------------------------------------------

     ================================================================== */

#ifndef QSPI_FLASH_CNTL_H_
#define QSPI_FLASH_CNTL_H_

/* qspi driver source code versions */
#define QSPI_FLASH_CONTROLLER_DRV_VER "v2024.1.1"

#define CLR_INTERRUPT			        		(0x00000FFFU)
#define FLASH_ADDRESS_FIFO_DIS					(0x00060000U)
#define FLASH_ADDRESS_FIFO_EN					(0x00080000U)
#define START_TRANS_VAL			        		(0x00000001U)
#define CLR_START_TRANS_VAL			    		(0x00000000U)
#define FLASH_CMD_CODE_READ		        		(0x0FU)
#define FLASH_CMD_CODE_WRITE		    		(0x17U)
#define FLASH_CMD_CODE_ERASE_TYPE_1				(0x10U)
#define FLASH_CMD_EXT_QUAD_INPUT_PAGE_PROGRAM 	(0x1BU)
#define FLASH_CMD_QUAD_INPUT_PAGE_PROGRAM 	    (0x1AU)
#define NUM_WAIT_CYCLE							(0x6U)
#define MULT_FLASH_TGT							(0U)
#define	WITH_PAYLOAD_WR							(1U)
#define WITH_PAYLOAD_RD							(0U)		// 0 for read & 1 for write
#define	SUPP_FLASH_CMD							(1U)
#define FLASH_ADDR_WIDTH_FIFO_DIS				(0x2U)
#define TGT_CS	           						(0x0U)
#define ADDR_LANE_WIDTH							(0x0U)
#define CMD_LANE_WIDTH							(0x0U)
#define FLASH_ADDR_WIDTH_FIFO_EN				(0x2U)
#define RET_FAILURE	   							(1U)
#define RET_SUCCESS								(0U)
#define IDLE									(0U)
#define IS_NULL									(0U)
#define TRANSFR_LEN_SHIFT						(16U)
#define FLASH_ADDR_WID_SHIFT_FIFO_EN			(12U)
#define FLASH_ADDR_WID_SHIFT_FIFO_DIS			(13U)
#define FLASH_CMD_CODE_SHIFT					(2U)
#define NUM_WAIT_CYCLE_SHIFT					(8U)
#define MULT_FLASH_TGT_SHIFT					(7U)
#define WITH_PAYLOAD_SHIFT						(1U)
#define TGT_CS_SHIFT							(8U)
#define DATA_LANE_WIDTH_SHIFT  					(4U)
#define ADDR_LANE_WIDTH_SHIFT					(2U)
#define INT_EN_VAL                      		(0x00000FFFU)
#define SET_PKT_HDR3                    		(0x0U)
#define CLR_START_TRANS             		    (0x0U)
#define REG_GAP                    		     	(2U)
#define IRQ_WR_FIFO_EN		            		(0U)
#define IRQ_RD_FIFO_EN		            		(1U)
#define IRQ_WR_FIFO_DIS							(0U)
#define IRQ_RD_FIFO_DIS	                		(0U)
#define TRANS_STS   							(1U)
#define CLR_IRQ_STS_VAR                 		(0U)
#define IDX_ZERO			            		(0U)
#define IDX_ONE						    		(1U)
#define IDX_TWO						    		(2U)
#define INCREMENT_ONE				    		(1U)
#define INCREMENT_TWO				    		(2U)
#define ENABLE_XIP_TRANS_BIT 					(0x2U)
#define DISABLE_XIP_TRANS_BIT					(0x0U)
#define ENABLE									(0x1U)
#define DISABLE									(0x0U)

#define TGT_RD_TRANS_CNT				(0x00100000U)
#define TGT_WR_TRANS_CNT				(0x00000000U)

// Flash Command Code 3 Register
#define QUAD_IO_FAST_RD_CMD_CODE					(0x000000ECU)

// Flash Command Code 7 Register
#define ENTER_4_BYTE_ADDR_MODE_CMD_CODE				(0xB7000000U)
#define EXIT_4_BYTE_ADDR_MODE_CMD_CODE				(0x008C0000U)
#define ENTER_QUAD_IO_MODE_CMD_CODE					(0x1EU)
#define RESET_QUAD_IO_CMD_CODE						(0x1FU)
#define FLASH_CMD_CODE_7_REG_CMD_QUAD_EN			(0x00003500U)
#define PKT_HDR_0_CMD_QUAD_EN						(0x00000079U)
#define PKT_HDR_1_CMD_QUAD_EN						(0x00000000U)
#define FLASH_CMD_CODE_7_REG_CMD_QUAD_RST			(0x000000F5U)
#define PKT_HDR_0_CMD_QUAD_RST						(0x0000007DU)
#define PKT_HDR_1_CMD_QUAD_RST						(0x0000002AU)
#define PKT_HDR_0_XIP_ENABLE						(0x86029U)
#define PKT_HDR_0_XIP_ENABLE_READ					(0x80048U)
#define PKT_DATA_0_XIP_ENABLE						(0xA55A00U)
#define PKT_HDR_0_XIP_DISABLE						(0x66029U)
#define PKT_DATA_0_XIP_DISABLE						(0xAA5500U)
#define PKT_HDR_0_XIP_DISABLE_READ					(0x60048U)

#define CHECK_ONE						(1U)
#define CHECK_TWO						(2U)
#define SHIFT_FOUR						(4U)

#define FLASH_ADDR_SHIFT				(8U)
#define FLASH_ADDR_MSB				    (0)

#define EN_FRAME_END_DONE_CNTR		    (0x00000U)
#define EN_FLASH_ADDR_SPACE_MAP		    (0x00000U)

#define LITTLE_ENDIAN					(0x00000U)
#define BIG_ENDIAN					    (0x02000U)

#define USE_BIG_ENDIAN					(0x1)

#define DIV_BY_2				        (0x0100U)
#define DIV_BY_4				        (0x0200U)
#define DIV_BY_8				        (0x0300U)

#define CHIP_SEL_BEH				    (0x000U)

#define MIN_IDLE_TIME				    (0x000U)

#define EN_BACK_TO_BACK_TRANS			(0x00U)

#define SAMPLE_ODD_EDGES				(0x00U)
#define SAMPLE_EVEN_EDGES				(0x04U)

#define ACTIVE_LOW						(0x00U)
#define ACTIVE_HIGH						(0x02U)

#define MSB_FIRST						(0x00U)
#define LSB_FIRST						(0x01U)

// Packet header 0
#define XFER_LEN_BYTES                  (0x00000000U)
#define NUM_WAIT_STATE                  (0x00000U)
#define MULT_FLASH_TARGET               (0x000U)
#define FLASH_CMD_CODE                  (0x070U)
#define WITH_PAYLOAD                    (0x00U)
#define SUPPORTED_FLASH_CMD             (0x01U)

// Packet header 1
#define FLASH_ADDRESS_WIDTH             (0x00000U)
#define TARGET_CS		                (0x00000U)
#define DATA_LANE_WIDTH		            (0x000U)
#define ADDRESS_LANE_WIDTH		        (0x00U)
#define COMMAND_LANE_WIDTH		        (0x00U)

// jedec manufacturer ids
#define JEDEC_MANUFACTURER_ID_MICRON		(0x20)
#define JEDEC_MANUFACTURER_ID_MACRONIX		(0xC2)
#define JEDEC_MANUFACTURER_ID_WINBOND		(0xEF)

typedef enum {
	REG_QSPI_CONFIG_0 = 1,
	REG_QSPI_CONFIG_1,
	REG_QSPI_FLASH_CMD_CODE_0,
	REG_QSPI_FLASH_CMD_CODE_1,
	REG_QSPI_FLASH_CMD_CODE_2,
	REG_QSPI_FLASH_CMD_CODE_3,
	REG_QSPI_FLASH_CMD_CODE_4,
	REG_QSPI_FLASH_CMD_CODE_5,
	REG_QSPI_FLASH_CMD_CODE_6,
	REG_QSPI_FLASH_CMD_CODE_7,
	REG_MIN_FLASH_ADDR_ALIGN,
	REG_START_FLASH_ADDR,
	REG_FLASH_ADDR_SPACE_MAP_SIZE,
	REG_AXI_ADDR_MAP,
	REG_TRANS_STATUS = 64,
	REG_INT_STATUS,
	REG_INT_ENABLE,
	REG_INT_SET,
	REG_SUPP_FLASH_CMD_PKT_HDR,
	REG_UNSUPP_FLASH_CMD_PKT_HDR,
	REG_TX_FIFO_MAP = 128,
	REG_RX_FIFO_MAP,
	REG_PACKET_HDR_0,
	REG_PACKET_HDR_1,
	REG_PACKET_HDR_2,
	REG_PACKET_HDR_3,
	REG_PACKET_DATA_0,
	REG_PACKET_DATA_1,
	REG_START_TRANS,
	REG_EN_LOOPBACK_TEST,
}qspi_reg_type_t;

typedef enum {
	LANE_WIDTH_X1 = 0x0,
	LANE_WIDTH_X2 = 0x1,
	LANE_WIDTH_X4 = 0x2,
}lane_width_t;

typedef enum{
	FLASH_NO_ADDR = 0x0,
	FLASH_16BIT_ADDR = 0x1,
	FLASH_24BIT_ADDR = 0x2,
	FLASH_32BIT_ADDR = 0x3,
	FLASH_40BIT_ADDR = 0x4,
	FLASH_48BIT_ADDR = 0x5,
	FLASH_56BIT_ADDR = 0x6,
	FLASH_64BIT_ADDR = 0x7,
}flash_addr_width_t;

typedef struct  {
	// configuration registers (0x0004 to 0x00FF) Reserved 0x0000 and, from 0x003C to 0x00FF
	volatile unsigned int REG_RESERVED;
	volatile unsigned int REG_QSPI_CONFIG_0;        // 0x0004
	volatile unsigned int REG_QSPI_CONFIG_1;        // 0x0008
	volatile unsigned int REG_QSPI_FLASH_CMD_CODE_0;
	volatile unsigned int REG_QSPI_FLASH_CMD_CODE_1;
	volatile unsigned int REG_QSPI_FLASH_CMD_CODE_2;
	volatile unsigned int REG_QSPI_FLASH_CMD_CODE_3;
	volatile unsigned int REG_QSPI_FLASH_CMD_CODE_4;
	volatile unsigned int REG_QSPI_FLASH_CMD_CODE_5;
	volatile unsigned int REG_QSPI_FLASH_CMD_CODE_6;
	volatile unsigned int REG_QSPI_FLASH_CMD_CODE_7;
	volatile unsigned int REG_MIN_FLASH_ADDR_ALIGN;
	volatile unsigned int REG_START_FLASH_ADDR;
	volatile unsigned int REG_FLASH_MEM_MAP_SIZE;
	volatile unsigned int REG_AXI_ADDR_MAP; 		// 0x0038
	volatile unsigned int reserved_reg1[49];
	// status & interrupt registers (0x0100 to 0x01FF)  Reserved from 0x0118 to 0x1FF
	volatile unsigned int REG_TRANS_STATUS;	// 0x0100
	volatile unsigned int REG_INT_STATUS;	// 0x0104
	volatile unsigned int REG_INT_ENABLE;   // 0x0108
	volatile unsigned int REG_INT_SET;
	volatile unsigned int REG_SUPP_FLASH_CMD_PKT_HDR;
	volatile unsigned int REG_UNSUPP_FLASH_CMD_PKT_HDR;		// 0x0114
	volatile unsigned int reserved_reg2[58];
	// Control Registers (0x0200 to 0x02FF)		Reserved from 0x0228 to 0x02FF
	volatile unsigned int REG_TX_FIFO_MAP; 		  // 0x0200
	volatile unsigned int REG_RX_FIFO_MAP;		  // 204
	volatile unsigned int REG_PACKET_HDR_0;       // 208
	volatile unsigned int REG_PACKET_HDR_1;       // 20C
	volatile unsigned int REG_PACKET_HDR_2;		  // 210
	volatile unsigned int REG_PACKET_HDR_3;		  //214
	volatile unsigned int REG_PACKET_DATA_0;	  // 218
	volatile unsigned int REG_PACKET_DATA_1;	  //21C
	volatile unsigned int REG_START_TRANS;   	  // 220
	volatile unsigned int REG_EN_LOOPBACK_TEST;	  // 0x0224

}qspi_flash_cntl_reg_t;

typedef enum {
	FLASH_CMD_CODE_READ_STATUS_REGISTER_1 					= 0x00,
	FLASH_CMD_CODE_READ_STATUS_REGISTER_2 					= 0x01,
	FLASH_CMD_CODE_READ_STATUS_REGISTER_3 					= 0x02,
	FLASH_CMD_CODE_READ_CONFIGURATION_REGISTER 				= 0x03,
	FLASH_CMD_CODE_READ_ID 									= 0x04,
	FLASH_CMD_CODE_READ_ELECTRONIC_ID 						= 0x05,
	FLASH_CMD_CODE_MULTIPLE_IO_READ_ID 						= 0x06,
	FLASH_CMD_CODE_READ_MANUFACTURER_AND_DEVICE_ID 			= 0x07,
	FLASH_CMD_CODE_READ_MANUFACTURER_AND_DEVICE_ID_DUAL 	= 0x08,
	FLASH_CMD_CODE_READ_MANUFACTURER_AND_DEVICE_ID_QUAD 	= 0x09,
	FLASH_CMD_CODE_READ_DATA 								= 0x0A,
	FLASH_CMD_CODE_FAST_READ 								= 0x0B,
	FLASH_CMD_CODE_DUAL_OUTPUT_FAST_READ					= 0x0C,
	FLASH_CMD_CODE_DUAL_INPUT_OUTPUT_FAST_READ				= 0x0D,
	FLASH_CMD_CODE_QUAD_OUTPUT_FAST_READ					= 0x0E,
	FLASH_CMD_CODE_QUAD_INPUT_OUTPUT_FAST_READ				= 0x0F,
	FLASH_CMD_CODE_BLOCK_ERASE_TYPE_1						= 0x10,
	FLASH_CMD_CODE_BLOCK_ERASE_TYPE_2						= 0x11,
	FLASH_CMD_CODE_BLOCK_ERASE_TYPE_3						= 0x12,
	FLASH_CMD_CODE_CHIP_ERASE								= 0x13,
	FLASH_CMD_CODE_WRITE_ENABLE								= 0x14,
	FLASH_CMD_CODE_WRITE_DISABLE							= 0x15,
	FLASH_CMD_CODE_WRITE_STATUS_CONFIG_REGISTER				= 0x16,
	FLASH_CMD_CODE_PAGE_PROGRAM								= 0x17,
	FLASH_CMD_CODE_DUAL_INPUT_FAST_PROGRAM					= 0x18,
	FLASH_CMD_CODE_EXTENDED_DUAL_INPUT_FAST_PROGRAM			= 0x19,
	FLASH_CMD_CODE_QUAD_INPUT_FAST_PROGRAM					= 0x1A,
	FLASH_CMD_CODE_EXTENDED_QUAD_INPUT_FAST_PROGRAM			= 0x1B,
	FLASH_CMD_CODE_ENTER_4_BYTE_ADDRESS_MODE				= 0x1C,
	FLASH_CMD_CODE_EXIT_4_BYTE_ADDRESS_MODE					= 0x1D,
	FLASH_CMD_CODE_ENTER_QUAD_INPUT_OUTPUT_MODE				= 0x1E,
	FLASH_CMD_CODE_EXIT_QUAD_INPUT_OUTPUT_MODE				= 0x1F
} flash_cmd_code_table_t;

// SPI mode
typedef enum {
	FLASH_CNTL_SPI_MODE = 0,
	FLASH_CNTL_QSPI_MODE = 1,
	FLASH_CNTL_EXTENDED_SPI_MODE = 2
} spi_mode_t;

struct qspi_flash_cntl_instance_t{
	unsigned int base_address;
	unsigned int status;
	unsigned int config_0;
	unsigned int config_1;
};

typedef struct {
	unsigned int supp_flash_cmd : 1; // h0
	unsigned int with_payload : 1;
	unsigned int flash_cmd_code : 5;
	unsigned int mult_flash_tgt : 1;
	unsigned int num_wait_cycle : 8;
	unsigned int buff_length : 16;
	unsigned int cmd_lane_width : 2;
	unsigned int addr_lane_width : 2;
	unsigned int data_lane_width : 2;
	unsigned int reservedbits_2 : 2;
	unsigned int tgt_cs : 5;
	unsigned int flash_addr_width : 3;
	unsigned int reservedbits_1 : 16;
	unsigned int flash_addr_LSB : 32;
	unsigned int flash_addr_MSB : 32;
}qspi_params_ext_t;

typedef struct {
	unsigned int packet_header0;
	unsigned int packet_header1;
	unsigned int packet_header2;
	unsigned int packet_header3;
}qspi_params_reg_t;

typedef union {
	qspi_params_ext_t params_ext_t;
	qspi_params_reg_t params_reg_t;

}qspi_params_t;

unsigned int qspi_flash_cntl_init(struct qspi_flash_cntl_instance_t * this_qspi_flash_cntl);
unsigned int qspi_flash_cntl_read(struct qspi_flash_cntl_instance_t *this_qspi_flash_cntl,
		qspi_reg_type_t index, unsigned int *reg_data);
unsigned int qspi_flash_cntl_write(struct qspi_flash_cntl_instance_t *this_qspi_flash_cntl,
		qspi_reg_type_t index, unsigned int reg_data);
unsigned int qspi_flash_cntl_write_erase_fifo_en(qspi_params_t *this_qspi_fifo ,unsigned int *buffer);
unsigned char qspi_flash_cntl_write_erase_fifo_dis(qspi_params_t *this_qspi_pkt, unsigned int *buffer);
void qspi_flash_cntl_read_fifo_en(qspi_params_t *this_qspi_fifo ,unsigned int *buffer);
unsigned char qspi_flash_cntl_read_fifo_dis(	unsigned int flash_addr,
												unsigned int flash_addr_width,
												unsigned int spi_mode,
												unsigned int  *buffer,
												unsigned int buffer_len,
												unsigned int manufacturer_id);
void qspi_flash_cntl_set_pkt_hdr(qspi_params_t *this_pkt_hdr);
void qspi_flash_cntl_set_tx_fifo(qspi_params_t *this_tx_fifo);
void enable_quad_mode();
void reset_quad_mode();

#endif				/* QSPI_FLASH_CNTL_H_ */
