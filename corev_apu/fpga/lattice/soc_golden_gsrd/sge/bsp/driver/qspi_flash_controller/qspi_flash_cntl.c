/*   ==================================================================

     >>>>>>>>>>>>>>>>>>>>>>> COPYRIGHT NOTICE <<<<<<<<<<<<<<<<<<<<<<<<<
     ------------------------------------------------------------------
     Copyright (c) 2019-2024 by Lattice Semiconductor Corporation
     ALL RIGHTS RESERVED
     ------------------------------------------------------------------

       IMPORTANT: THIS FILE IS USED BY OR GENERATED BY the LATTICE PROPELâ„¢
       DEVELOPMENT SUITE, WHICH INCLUDES PROPEL BUILDER AND PROPEL SDK.

       Lattice grants permission to use this code pursuant to the
       terms of the Lattice Propel License Agreement.

     DISCLAIMER:

    LATTICE MAKES NO WARRANTIES ON THIS FILE OR ITS CONTENTS,
    WHETHER EXPRESSED, IMPLIED, STATUTORY,
    OR IN ANY PROVISION OF THE LATTICE PROPEL LICENSE AGREEMENT OR
    COMMUNICATION WITH LICENSEE,
    AND LATTICE SPECIFICALLY DISCLAIMS ANY IMPLIED WARRANTY OF
    MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.
    LATTICE DOES NOT WARRANT THAT THE FUNCTIONS CONTAINED HEREIN WILL MEET
    LICENSEE 'S REQUIREMENTS, OR THAT LICENSEE' S OPERATION OF ANY DEVICE,
    SOFTWARE OR SYSTEM USING THIS FILE OR ITS CONTENTS WILL BE
    UNINTERRUPTED OR ERROR FREE,
    OR THAT DEFECTS HEREIN WILL BE CORRECTED.
    LICENSEE ASSUMES RESPONSIBILITY FOR SELECTION OF MATERIALS TO ACHIEVE
    ITS INTENDED RESULTS, AND FOR THE PROPER INSTALLATION, USE,
    AND RESULTS OBTAINED THEREFROM.
    LICENSEE ASSUMES THE ENTIRE RISK OF THE FILE AND ITS CONTENTS PROVING
    DEFECTIVE OR FAILING TO PERFORM PROPERLY AND IN SUCH EVENT,
    LICENSEE SHALL ASSUME THE ENTIRE COST AND RISK OF ANY REPAIR, SERVICE,
    CORRECTION,
    OR ANY OTHER LIABILITIES OR DAMAGES CAUSED BY OR ASSOCIATED WITH THE
    SOFTWARE.IN NO EVENT SHALL LATTICE BE LIABLE TO ANY PARTY FOR DIRECT,
    INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES,
    INCLUDING LOST PROFITS,
    ARISING OUT OF THE USE OF THIS FILE OR ITS CONTENTS,
    EVEN IF LATTICE HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.
    LATTICE 'S SOLE LIABILITY, AND LICENSEE' S SOLE REMEDY,
    IS SET FORTH ABOVE.
    LATTICE DOES NOT WARRANT OR REPRESENT THAT THIS FILE,
    ITS CONTENTS OR USE THEREOF DOES NOT INFRINGE ON THIRD PARTIES'
    INTELLECTUAL PROPERTY RIGHTS, INCLUDING ANY PATENT. IT IS THE USER' S
    RESPONSIBILITY TO VERIFY THE USER SOFTWARE DESIGN FOR CONSISTENCY AND
    FUNCTIONALITY THROUGH THE USE OF FORMAL SOFTWARE VALIDATION METHODS.
     ------------------------------------------------------------------

     ================================================================== */
#include "qspi_flash_cntl.h"

static volatile qspi_flash_cntl_reg_t *flash_cntl;
/**
 * @brief 	Initializes the QSPI flash controller instance with the provided base address and status.
 *
 * This function initializes the QSPI flash controller instance pointed by 'this_qspi_flash_cntl'
 * with the given 'base_addr'. It also sets the status of the flash controller
 * to 'IDLE'.
 *
 * @param 	this_qspi_flash_cntl	 Pointer to the QSPI flash controller instance.
 * @param 	base_addr 				 The base address of the QSPI flash controller registers.
 * @return 	                         Returns 'SUCCESS' (0) on successful initialization, or 'FAILURE' (1) if 'this_qspi_flash_cntl' is NULL.
 */
unsigned int qspi_flash_cntl_init(struct qspi_flash_cntl_instance_t *this_qspi_flash_cntl) {
	if(this_qspi_flash_cntl == IS_NULL) {
		return RET_FAILURE;
	}
	flash_cntl = (volatile qspi_flash_cntl_reg_t *)this_qspi_flash_cntl->base_address;
	flash_cntl->REG_QSPI_CONFIG_0 = this_qspi_flash_cntl->config_0;
	flash_cntl->REG_QSPI_CONFIG_1 = this_qspi_flash_cntl->config_1;
	this_qspi_flash_cntl->status = IDLE;
	return RET_SUCCESS;
}

/**
 * @brief 	Initiate the SPI transaction
 *
 * This function inititate the SPI transaction by configure the start transaction register (0x220)
 *
 * @return 	                         Returns 'SUCCESS' (0) on successful transaction.
 */

unsigned int qspi_trans_start(void) {
	unsigned int sts = 0;
	
	flash_cntl->REG_START_TRANS = START_TRANS_VAL;
	while (sts & CHECK_ONE != 0) {
		sts = flash_cntl->REG_TRANS_STATUS;
	}
	return RET_SUCCESS;
}

/**
 * @brief 	Reads the value from the specified register.
 *
 * This function reads the value from the QSPI flash controller registers
 * specified by 'index' and stores the result in the 'reg_data' pointer.
 *
 * @param   this_qspi_flash_cntl  Pointer to the QSPI flash controller instance.
 * @param   index                 The index of the QSPI configuration register to read.
 * @param   reg_data              Pointer to a variable where the read register value will be stored.
 * @return                        Returns 'SUCCESS' (0) on successful read, or 'FAILURE' (1) if 'this_qspi_flash_cntl' is NULL.
 */
unsigned int qspi_flash_cntl_read(struct qspi_flash_cntl_instance_t *this_qspi_flash_cntl,
		qspi_reg_type_t index, unsigned int *reg_data) {
	if(this_qspi_flash_cntl == IS_NULL) {
		return RET_FAILURE;
	}
	volatile unsigned int base_addr = (unsigned int)(this_qspi_flash_cntl->base_address);
	volatile unsigned int *read_reg = (unsigned int *)(base_addr + (index<<REG_GAP));
	*reg_data = *read_reg;

	return RET_SUCCESS;
}

/**
 * @brief 	Writes the specified value to the QSPI register.
 *
 * This function writes the value 'reg_data' to the QSPI flash controller register
 * specified by 'index'.
 *
 * @param   this_qspi_flash_cntl  Pointer to the QSPI flash controller instance.
 * @param   index                 The index of the QSPI configuration register to write.
 * @param   reg_data              The value to be written to the register.
 * @return                        Returns 'SUCCESS' (0) on successful write, or 'FAILURE' (1) if 'this_qspi_flash_cntl' is NULL.
 */
unsigned int qspi_flash_cntl_write(struct qspi_flash_cntl_instance_t *this_qspi_flash_cntl,
		qspi_reg_type_t index, unsigned int reg_data) {
	if(this_qspi_flash_cntl == IS_NULL) {
		return RET_FAILURE;
	}
	volatile unsigned int base_addr = (unsigned int)(this_qspi_flash_cntl->base_address);
	volatile unsigned int *write_reg = (unsigned int *)(base_addr + (index<<REG_GAP));
	*write_reg = reg_data;

	return RET_SUCCESS;
}

/**
 * @brief Write/Erase Flash Memory Data with QSPI Flash Controller when fifo is enable.
 *
 *This function is used to write/erase the data to the flash memory using TX FIFO.
 *
 * @param this_qspi_fifo   Pointer to the to the structure qspi_params_t.
 * @param buffer           Pointer to the buffer containing data to be written.
 * @return                 Returns 'SUCCESS' (0) on successful write, or 'FAILURE' (1) if 'buffer' is NULL.
 */
unsigned int qspi_flash_cntl_write_erase_fifo_en(qspi_params_t *this_qspi_fifo ,unsigned int *buffer) {
	unsigned int count_wr_fifo = 0;
	unsigned int irq_sts = 0;

	if (buffer == IS_NULL) {
		return RET_FAILURE;
	}

	/* Enable interrupt */
	flash_cntl->REG_INT_ENABLE = INT_EN_VAL; 
	qspi_flash_cntl_set_tx_fifo(this_qspi_fifo);

	while (count_wr_fifo < ((this_qspi_fifo->params_ext_t.buff_length)>>REG_GAP)) {
		/* Write the data */
		flash_cntl->REG_TX_FIFO_MAP = buffer[count_wr_fifo++]; 
	}

	/* Start transaction */
	flash_cntl->REG_START_TRANS = START_TRANS_VAL;
	
	/* Check interrupt */
	while ((irq_sts & CHECK_ONE) == IRQ_WR_FIFO_EN) {
		irq_sts = flash_cntl->REG_INT_STATUS;
	}
	flash_cntl->REG_START_TRANS = CLR_START_TRANS;
	return RET_SUCCESS;
}

/**
 * @brief Reads data from RX FIFO with QSPI flash controller with FIFO enable.
 *
 * This function is used to read the data from the flash memory using RX FIFO.
 *
 * @param buffer            Pointer to the buffer to store the read data.
 * @param this_qspi_fifo    Pointer to the structure qspi_params_t.
 */
void qspi_flash_cntl_read_fifo_en(qspi_params_t *this_qspi_fifo ,unsigned int *buffer) {
	unsigned int count_read_fifo = 0;

	qspi_flash_cntl_set_tx_fifo(this_qspi_fifo);
	/* Start transaction */
	flash_cntl->REG_START_TRANS = START_TRANS_VAL;
	while(((flash_cntl->REG_INT_STATUS>>SHIFT_FOUR) & CHECK_ONE) == IRQ_RD_FIFO_EN);
	/* Clear interupt */
	flash_cntl->REG_INT_STATUS = CLR_INTERRUPT;

	while(count_read_fifo < ((this_qspi_fifo->params_ext_t.buff_length)>>REG_GAP)) {
		/* Read data */
		buffer[count_read_fifo++] = flash_cntl->REG_RX_FIFO_MAP;
	}
	flash_cntl->REG_START_TRANS = CLR_START_TRANS;
}

/**
 * @brief Writes/erase the data to the flash memory with QSPI flash controller when FIFO is disable.
 *
 * This function is used to write/erase the data to the flash memory using Data Packet registers when fifo is disable.
 *
 * @param buffer          Pointer to the buffer containing data to be written.
 * @param this_qspi_pkt   Pointer to the structure qspi_params_t.
 * @return                Returns 'SUCCESS' (0) on successful write, or 'FAILURE' (1) if 'buffer' is NULL.
 */
unsigned char qspi_flash_cntl_write_erase_fifo_dis(qspi_params_t *this_qspi_pkt, unsigned int *buffer) {
	unsigned int irq_sts = 0;
	unsigned int trans_sts = 1;
	unsigned int idx = 2;

	if ((this_qspi_pkt->params_ext_t.flash_cmd_code == FLASH_CMD_CODE_WRITE ||
		this_qspi_pkt->params_ext_t.flash_cmd_code == FLASH_CMD_EXT_QUAD_INPUT_PAGE_PROGRAM ||
		this_qspi_pkt->params_ext_t.flash_cmd_code == FLASH_CMD_QUAD_INPUT_PAGE_PROGRAM) &&
		buffer == IS_NULL) {
		return RET_FAILURE;
	}

	/* Enable interrupt */
	flash_cntl->REG_INT_ENABLE = INT_EN_VAL;
	/* Clear interrupt */
	flash_cntl->REG_INT_STATUS = CLR_INTERRUPT;
	/* Write packet headers */
	qspi_flash_cntl_set_pkt_hdr(this_qspi_pkt);

	if (this_qspi_pkt->params_ext_t.flash_cmd_code == FLASH_CMD_CODE_WRITE ||
		this_qspi_pkt->params_ext_t.flash_cmd_code == FLASH_CMD_EXT_QUAD_INPUT_PAGE_PROGRAM ||
		this_qspi_pkt->params_ext_t.flash_cmd_code == FLASH_CMD_QUAD_INPUT_PAGE_PROGRAM) {
		/* Write the data for first transaction */
		flash_cntl->REG_PACKET_DATA_0 = buffer[0];
		flash_cntl->REG_PACKET_DATA_1 = buffer[1];

		/* Start SPI transaction*/
		qspi_trans_start();

		while (idx < ((this_qspi_pkt->params_ext_t.buff_length)>>REG_GAP)) {
			/* Check wr_pkt_data_0_empty_int_stat to write the next packet data 0 & 1 */
			while (((irq_sts & CHECK_ONE) == IRQ_WR_FIFO_DIS) && ((irq_sts & CHECK_TWO) == IRQ_WR_FIFO_DIS))
			{
				irq_sts = flash_cntl->REG_INT_STATUS;
			}
			/* Clear interrupt */
			flash_cntl->REG_INT_STATUS = CLR_INTERRUPT;

			/*Write date buffer tp DATA_0 and DATA_1 */
			flash_cntl->REG_PACKET_DATA_0 = buffer[idx];
			flash_cntl->REG_PACKET_DATA_1 = buffer[idx+INCREMENT_ONE];
			irq_sts = CLR_IRQ_STS_VAR;
			idx+=IDX_TWO;
		}
	}
	if (this_qspi_pkt->params_ext_t.flash_cmd_code == FLASH_CMD_CODE_ERASE_TYPE_1) {
		/* Start SPI transaction*/
		qspi_trans_start();
	}
	/* Poll status until transaction status deasserted */
	while (trans_sts & CHECK_ONE != 0) {
		trans_sts = flash_cntl->REG_TRANS_STATUS;
	}
	/* Clear interrupt and start transaction register */
	flash_cntl->REG_INT_STATUS = CLR_INTERRUPT;
	flash_cntl->REG_START_TRANS = CLR_START_TRANS;

	return RET_SUCCESS;
}

/**
 * @brief Function to convert Big Endian to Little Endian (32bit).
 *
 * This function is used to convert 32 bit data from Big Endian to Little Endian.
 *
 * @param input   		  Data input.
 * @return                Little Endian as return data
 *
 */

unsigned int convert_endian(unsigned int input) {
	return (   ((input & 0xFF) << 24) |
		       ((input & 0xFF00) << 8) |
	           ((input >> 8) & 0xFF00) |
	           (input >> 24)
	       );
}

/**
 * @brief Reads data from the flash memory with QSPI flash controller when FIFO is disabled.
 *
 * This function is used to read the data from the flash memory using Data Packet register when fifo is disable.
 *
 * @param flash_addr   			Starting flash address to read from.
 * @param flash_addr_width      Width of the flash address.
 * @param spi_mode   			SPI mode to use (Dual,Quad).
 * @param *buffer          		Pointer to the buffer to store the read data.
 * @param buffer_len   			Buffer length in Header 0.
 * @param manufacturer_id       Manufacturer ID.
 * @return                      Returns 'SUCCESS' (0) on successful write, or 'FAILURE' (1) if 'buffer' is NULL.
 *
 */
unsigned char qspi_flash_cntl_read_fifo_dis(	unsigned int flash_addr,
												unsigned int flash_addr_width,
												unsigned int spi_mode,
												unsigned int  *buffer,
												unsigned int buffer_len,
												unsigned int manufacturer_id) {
	unsigned int len = 0;

	if (buffer == IS_NULL)
		return RET_FAILURE;

	qspi_params_t qspi_params = { 0, 0, 0, 0 };

	flash_cntl->REG_START_TRANS = 0;

	/* Configure packet header */
	qspi_params.params_ext_t.flash_addr_width = flash_addr_width;
	if (flash_addr_width == FLASH_24BIT_ADDR) {
		qspi_params.params_ext_t.flash_addr_LSB = flash_addr << 8;
	} else {
		qspi_params.params_ext_t.flash_addr_LSB = flash_addr;
	}

	qspi_params.params_ext_t.flash_addr_MSB = 0x00000000;
	if (spi_mode == FLASH_CNTL_SPI_MODE) {
		qspi_params.params_ext_t.cmd_lane_width = LANE_WIDTH_X1;
		qspi_params.params_ext_t.addr_lane_width = LANE_WIDTH_X1;
		qspi_params.params_ext_t.data_lane_width = LANE_WIDTH_X1;
		qspi_params.params_ext_t.flash_cmd_code = FLASH_CMD_CODE_FAST_READ;
		printf("FLASH_CMD_CODE_FAST_READ\r\n");
		/* 8 dummy clock cycles for basic Fast Read command */
		qspi_params.params_ext_t.num_wait_cycle = 8;
	}
	else if (spi_mode == FLASH_CNTL_QSPI_MODE) {
		/* _________________________________
		 * | Manufacturer | Cmd Lane Width |
		 * |--------------|----------------|
		 * | Winbond      | LANE_WIDTH_X1  |
		 * | Macronix     | LANE_WIDTH_X4  |
		 * | Micron       | LANE_WIDTH_X4  |
		 * ---------------------------------
		 */
		if (manufacturer_id == JEDEC_MANUFACTURER_ID_WINBOND)
			qspi_params.params_ext_t.cmd_lane_width = LANE_WIDTH_X1;
		else
			qspi_params.params_ext_t.cmd_lane_width = LANE_WIDTH_X4;
		qspi_params.params_ext_t.addr_lane_width = LANE_WIDTH_X4;
		qspi_params.params_ext_t.data_lane_width = LANE_WIDTH_X4;
		qspi_params.params_ext_t.flash_cmd_code = FLASH_CMD_CODE_QUAD_INPUT_OUTPUT_FAST_READ;
		printf("FLASH_CMD_CODE_QUAD_INPUT_OUTPUT_FAST_READ\r\n");

		/* 6 dummy clock cycles (winbond) for Quad I/O Fast Read */
		qspi_params.params_ext_t.num_wait_cycle = 6;
	}

	qspi_params.params_ext_t.buff_length = buffer_len;
	qspi_params.params_ext_t.with_payload = 0;

	/* Single falsh target */
	qspi_params.params_ext_t.mult_flash_tgt = 0;

	/* Supported command */
	qspi_params.params_ext_t.supp_flash_cmd = 1;

	/* Write packet headers */
	qspi_flash_cntl_set_pkt_hdr(&qspi_params);

	/* Enable interrupt */
	flash_cntl->REG_INT_ENABLE = INT_EN_VAL;

	/* Start SPI transaction*/
	qspi_trans_start();

	for (len = IDX_ZERO; len < ((buffer_len)>>REG_GAP); len++) {
	    /* Check the interrupt */
		while (((flash_cntl->REG_INT_STATUS >> SHIFT_FOUR) & CHECK_ONE) == IRQ_RD_FIFO_DIS);
		/* Clear interrupt */
		flash_cntl->REG_INT_STATUS = CLR_INTERRUPT;
		printf("flash_cntl->REG_PACKET_DATA_0: 0x%x \r\n",flash_cntl->REG_PACKET_DATA_0);
		/* Check data endianess and store the data from DATA_0 */
#ifndef USE_BIG_ENDIAN
		*(buffer+len) = flash_cntl->REG_PACKET_DATA_0;
#else
		*(buffer+len) = convert_endian(flash_cntl->REG_PACKET_DATA_0);
#endif
	}

	return RET_SUCCESS;
}


/**
 * @brief Set Packet Header for QSPI Flash Controller Transaction.
 *
 * This function set the packet header registers based on the provided parameters.
 *
 * @param this_pkt_hdr    Pointer to the structure qspi_params_t containing the desired variables.
 *
 */
void qspi_flash_cntl_set_pkt_hdr(qspi_params_t *this_pkt_hdr) {
	flash_cntl->REG_PACKET_HDR_0 = this_pkt_hdr->params_reg_t.packet_header0;
	flash_cntl->REG_PACKET_HDR_1 = this_pkt_hdr->params_reg_t.packet_header1;
	flash_cntl->REG_PACKET_HDR_2 = this_pkt_hdr->params_reg_t.packet_header2;
	flash_cntl->REG_PACKET_HDR_3 = this_pkt_hdr->params_reg_t.packet_header3;
}

/**
 * @brief - Set up and transmit data to the QSPI flash controller TX FIFO.
 *
 * This Function configure the TX FIFO for the write/erase and read apis when fifo is enabled.
 *
 * @param this_tx_fifo   Pointer to the structure qspi_params_t containing the desired variables.
 */
void qspi_flash_cntl_set_tx_fifo(qspi_params_t *this_tx_fifo) {
	flash_cntl->REG_TX_FIFO_MAP = this_tx_fifo->params_reg_t.packet_header0;
	flash_cntl->REG_TX_FIFO_MAP = this_tx_fifo->params_reg_t.packet_header1;
	flash_cntl->REG_TX_FIFO_MAP = this_tx_fifo->params_reg_t.packet_header2;

}

/**
 * enable_quad_mode - Enable Quad Mode for the QSPI flash controller.
 *
 * @brief - This function sets up the necessary registers to enable Quad Mode for the QSPI flash controller.
 *
 */
void enable_quad_mode() {
	flash_cntl->REG_PACKET_HDR_0 = PKT_HDR_0_CMD_QUAD_EN;
	flash_cntl->REG_PACKET_HDR_1 = PKT_HDR_1_CMD_QUAD_EN;
	flash_cntl->REG_START_TRANS = START_TRANS_VAL;
	flash_cntl->REG_INT_STATUS = CLR_INTERRUPT;
	flash_cntl->REG_START_TRANS = CLR_START_TRANS;
}

/**
 * enable_xip_mode - Enable XiP Mode for the QSPI flash controller.
 *
 * @brief - This function sets up the necessary registers to enable XiP Mode for the QSPI flash controller.
 *
 * @param mode    		 XiP mode (1 for enable, 0 for disable).
 * @param flash_addr1    flash address MSB.
 * @param flash_addr2    flash address LSB.
 *
 */
void enable_xip_mode(unsigned int mode, unsigned int flash_addr, unsigned int opCode) {
	unsigned int trans_sts = 1;
	unsigned int data0, data1;
	/* Initiate a non-XiP generic transaction for the first Quad Input/Output Fast Read operation
	 * with 8â€™hEB opcode to enable the XiP mode of the Macronix flash for the succeeding reads
	 */
	if (mode == ENABLE) {
		flash_cntl->REG_PACKET_HDR_0 = PKT_HDR_0_XIP_ENABLE;
		flash_cntl->REG_PACKET_DATA_0 = (opCode | (flash_addr << 2)); //218
		flash_cntl->REG_PACKET_DATA_1 = (PKT_DATA_0_XIP_ENABLE | (flash_addr & 0x000000FF)); //21C
	}
	else {
		/* Disabling the XiP mode is same with enabling steps with xfer_len_bytes changed to 16â€™h6
		 * since command will not be sent during XiP enabled access and the
		 * 2-byte pattern will change to 16â€™hAA55 or 16â€™hFF00
		 */
		flash_cntl->REG_PACKET_HDR_0 = PKT_HDR_0_XIP_DISABLE;
		flash_cntl->REG_PACKET_DATA_1 = PKT_DATA_0_XIP_DISABLE;
	}

	/* Start SPI transaction*/
	qspi_trans_start();

	flash_cntl->REG_INT_STATUS = CLR_INTERRUPT;
	flash_cntl->REG_START_TRANS = CLR_START_TRANS;
	/* Reading the return data from flash */
	if (mode == DISABLE) {
		flash_cntl->REG_PACKET_HDR_0 = PKT_HDR_0_XIP_ENABLE_READ;
	}
	else {
		flash_cntl->REG_PACKET_HDR_0 = PKT_HDR_0_XIP_DISABLE_READ;
	}

	/* Start SPI transaction*/
	qspi_trans_start();

	flash_cntl->REG_INT_STATUS = CLR_INTERRUPT;
	flash_cntl->REG_START_TRANS = CLR_START_TRANS;
	data0 = flash_cntl->REG_PACKET_DATA_0;
	data1 = flash_cntl->REG_PACKET_DATA_1;
	
	/*Enable XiP bit in trans register*/
	if (mode == ENABLE)
		flash_cntl->REG_START_TRANS = ENABLE_XIP_TRANS_BIT;
	else
		flash_cntl->REG_START_TRANS = DISABLE_XIP_TRANS_BIT;
}
/**
 * xip_read_data - Read the flash data from system memory via XiP mode.
 *
 * @brief - This function return the flash data from system memory.
 *
 * @param offset    	 Address offset of the flash data.
 * @param base_address   Pointer of the QSPI base address
 *
 * @return               Returns the flash data.
 */
unsigned int xip_read_data(unsigned int *base_address, unsigned int offset) {
	if (base_address == IS_NULL)
		return RET_FAILURE;
	return (*(base_address + REG_AXI_ADDR_MAP) + offset);
}

/**
 * RESET_quad_mode - Reset Quad Mode for the QSPI flash controller.
 *
 * @brief - This function sets up the necessary registers to Reset Quad Mode for the QSPI flash controller.
 *
 */
void reset_quad_mode() {
	flash_cntl->REG_QSPI_FLASH_CMD_CODE_7 = FLASH_CMD_CODE_7_REG_CMD_QUAD_RST;
	flash_cntl->REG_PACKET_HDR_0 = PKT_HDR_0_CMD_QUAD_RST;
	flash_cntl->REG_PACKET_HDR_1 = PKT_HDR_1_CMD_QUAD_RST;
	flash_cntl->REG_START_TRANS = START_TRANS_VAL;
	flash_cntl->REG_INT_STATUS = CLR_INTERRUPT;
	flash_cntl->REG_START_TRANS = CLR_START_TRANS;
}
