// >>>>>>>>>>>>>>>>>>>>>>> COPYRIGHT NOTICE <<<<<<<<<<<<<<<<<<<<<<<<<
// ------------------------------------------------------------------
// Copyright (c) 2019-2023 by Lattice Semiconductor Corporation
// ALL RIGHTS RESERVED
// ------------------------------------------------------------------
//
// IMPORTANT: THIS FILE IS USED BY OR GENERATED BY the LATTICE PROPEL
// DEVELOPMENT SUITE, WHICH INCLUDES PROPEL BUILDER AND PROPEL SDK.
//
// Lattice grants permission to use this code pursuant to the
// terms of the Lattice Propel License Agreement.
//
// DISCLAIMER:
//
//  LATTICE MAKES NO WARRANTIES ON THIS FILE OR ITS CONTENTS, WHETHER
//  EXPRESSED, IMPLIED, STATUTORY, OR IN ANY PROVISION OF THE LATTICE
//  PROPEL LICENSE AGREEMENT OR COMMUNICATION WITH LICENSEE, AND LATTICE 
//  SPECIFICALLY DISCLAIMS ANY IMPLIED WARRANTY OF MERCHANTABILITY OR
//  FITNESS FOR A PARTICULAR PURPOSE.  LATTICE DOES NOT WARRANT THAT THE
//  FUNCTIONS CONTAINED HEREIN WILL MEET LICENSEE'S REQUIREMENTS, OR THAT
//  LICENSEE'S OPERATION OF ANY DEVICE, SOFTWARE OR SYSTEM USING THIS FILE
//  OR ITS CONTENTS WILL BE UNINTERRUPTED OR ERROR FREE, OR THAT DEFECTS
//  HEREIN WILL BE CORRECTED.  LICENSEE ASSUMES RESPONSIBILITY FOR 
//  SELECTION OF MATERIALS TO ACHIEVE ITS INTENDED RESULTS, AND FOR THE
//  PROPER INSTALLATION, USE, AND RESULTS OBTAINED THEREFROM.  LICENSEE
//  ASSUMES THE ENTIRE RISK OF THE FILE AND ITS CONTENTS PROVING DEFECTIVE
//  OR FAILING TO PERFORM PROPERLY AND IN SUCH EVENT, LICENSEE SHALL 
//  ASSUME THE ENTIRE COST AND RISK OF ANY REPAIR, SERVICE, CORRECTION, OR
//  ANY OTHER LIABILITIES OR DAMAGES CAUSED BY OR ASSOCIATED WITH THE 
//  SOFTWARE.  IN NO EVENT SHALL LATTICE BE LIABLE TO ANY PARTY FOR DIRECT,
//  INDIRECT,SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST
//  PROFITS, ARISING OUT OF THE USE OF THIS FILE OR ITS CONTENTS, EVEN IF
//  LATTICE HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES. LATTICE'S
//  SOLE LIABILITY, AND LICENSEE'S SOLE REMEDY, IS SET FORTH ABOVE.  
//  LATTICE DOES NOT WARRANT OR REPRESENT THAT THIS FILE, ITS CONTENTS OR
//  USE THEREOF DOES NOT INFRINGE ON THIRD PARTIES' INTELLECTUAL PROPERTY
//  RIGHTS, INCLUDING ANY PATENT. IT IS THE USER'S RESPONSIBILITY TO VERIFY
//  THE USER SOFTWARE DESIGN FOR CONSISTENCY AND FUNCTIONALITY THROUGH THE
//  USE OF FORMAL SOFTWARE VALIDATION METHODS.
// ------------------------------------------------------------------

#include "gpio.h"
#include "hal.h"
#include "utils.h"
#include <stdio.h>
#include "sys_platform.h"
#include "qspi_flash_cntl.h"
#include "crc16.h"
#include "ddr_mc_avant.h"

extern void os_init();

/**
 * @brief control register variable passed from user side
 */
#define RCV_ALL_ADDR_FRAME					0x01
#define RCV_MULTICAST						0x10
#define RCV_BROADCAST						0x80
#define	RCV_SHORT_FRAME						0x100
#define RCV_PAUSE_FRAME						0x08
/**
 * @brief Mode register variable passed from user side
 */
#define	ENABLE_Tx_MODE						0x08
#define	ENABLE_Rx_MODE						0x04

/**
 * @brief Mode register variable
 */
#define Rx_MAC_EN			0x04
#define Tx_MAC_EN			0x08

/**
 * @brief Control register variable
 */
#define PRMS_MODE_EN			0
#define Rx_FCS_DISABLE			1
#define Tx_FCS_DISABLE			2
#define PAUSE_FRAME_RCV			3
#define MULTICAST_FRAME_RCV		4
#define HALF_DUPLEX_MODE		5
#define DROP_CONTROL			6
#define BROADCAST_FRAME_RCV		7
#define SHORT_FRAME_RCV			8

/**
 * @brief status register
 */
#define	Tx_MAC_IDLE							0x01
#define	PAUSE_FRAME							0x02
#define CRC_ERROR							0x04
#define FRAME_ERROR							0x08
#define	LONG_FRAME							0x10
#define SHORT_FRAME							0x20
#define IPG_SHRINK							0x40
#define MULTICAST_FRAME						0x80
#define	BROADCAST_FRAME						0x100
#define TAGGED_FRAME						0x200
#define	Rx_MAC_IDLE							0x400

#define FLASH_ADDR_24BIT      24
#define FLASH_ADDR_32BIT      32
#define STANDARD_SPI_MODE	  1
#define QUAD_SPI_MODE		  4

#define FLASH_ADDR_MODE       FLASH_ADDR_32BIT
#define SPI_COMM_MODE         STANDARD_SPI_MODE

#define FLASH_CMD_CODE_STD_RD 		0x0B
#define NUM_WAIT_CYCLE_STD			0x8
#define STD_IO_FAST_RD_CMD_CODE		(0x0000000C)

#if(FLASH_ADDR_MODE == FLASH_ADDR_32BIT)
#define GOLDEN_COPY_MEMORY_START_ADDR      0x02800000
#define PRIMARY_COPY_MEMORY_START_ADDR     0x028A0000
#define MSB_MEMORY_START_ADDR      		   0x0
#define FLASH_ADDR_WIDTH 				   0x3
#elif(FLASH_ADDR_MODE == FLASH_ADDR_24BIT)
#define GOLDEN_COPY_MEMORY_START_ADDR      (0x00300000<<8)//0x00300000
#define PRIMARY_COPY_MEMORY_START_ADDR     (0x00400000<<8)
#define FLASH_ADDR_WIDTH 				   0x2
#endif
//#define CRC_CAL_ENABLED
#define CRC16_START_VAL  0x1D0F /* start value which is used by SRecord tool for -CRC16_Big_Endian */

#define LPDDR_APPLICATION_MEMORY_START_ADDR		(0x80000000)
#define LPDDR_APPLICATION_MEMORY_END_ADDR		(0x8003fffe)
#define LPDDR_FW_CRC							(0x8003fffc)
#define LPDDR_FW_SIZE							(0x40000U)//(PRIMARY_APPLICATION_MEMORY_END_ADDR - PRIMARY_APPLICATION_MEMORY_START_ADDR + 2)
#define QSPI_FW_FETCH_SIZE						(0xf000)
#define QSPI_FETCH_SEQ							7

#define MARVELL_PHY_88E151X	0x1D
#define PHY_REG_READ				0x0
#define PHY_REG_WRITE				0x1
#define PHY_REG_SHIFT				0x8
#define PHY_REG_READ_WRITE_SHIFT	0xc
#define PHY_REG_CMD_FIN				0x00004000

bool crc_check_status =true;

static struct qspi_flash_cntl_instance_t qspi_core;
static 	qspi_params_t pkt_param;
lpddr4 lpddr4_instance;

#if (defined UART0_INST_UART_MEM_MAP_BASE_ADDR) //&& (defined UART_INST_BASE_ADDR)
#include "uart.h"

struct uart_instance uart_core_uart;
#endif
#ifndef _UART_NO_INTERRUPTS_
#include "pic.h"
#endif

struct gpio_instance gpio_inst;
static int lscc_uart_putc(char c, FILE *file)
{
#ifdef LSCC_STDIO_UART_APB
	return uart_putc(&uart_core_uart, c);
#else
	return EOF;
#endif
}



static int lscc_uart_getc(FILE *file)
{
	(void) file;
	return EOF;
}


static int lscc_uart_flush(FILE *file)
{
	(void) file;
	return 0;
}


static void bsp_init(void)
{
	//initialize GPIO
	gpio_inst.instance_name = GPIO0_INST_GPIO_MEM_MAP_NAME;
	gpio_init(&gpio_inst, GPIO0_INST_GPIO_MEM_MAP_BASE_ADDR, GPIO0_INST_LINES_NUM, GPIO0_INST_GPIO_DIRS);

	//initialize UART
	uart_init(&uart_core_uart, UART0_INST_UART_MEM_MAP_BASE_ADDR, UART0_INST_SYS_CLK * 1000000, UART0_INST_BAUD_RATE, 1, 8);
	iob_init(lscc_uart_putc, lscc_uart_getc, lscc_uart_flush);
}

void write_burst_to_memory(volatile uint32_t *address, const uint32_t *data){
	for(int i = 0; i < 16; i++){
		address[i] = data[i];
		printf("\r\n	INFO: Data 0x%08X written to memory at address %p\r\n", data[i], (void*)&address[i]);
	}
}
void read_burst_from_memory(volatile uint32_t *address, uint32_t *data){
	for(int i = 0; i < 16; i++){
		data[i] = address[i];
		printf("\r\n	INFO: Data 0x%08X read from memory at address %p\r\n", data[i], (void*)&address[i]);
	}
}

void LPDDR_init()
{
	lpddr4_init(&lpddr4_instance,LPDDR4_MC_CONTR0_INST_MEMC_REG_MEM_MAP_BASE_ADDR);
}

void qspi_init()
{
	qspi_core.base_address = QSPI0_INST_QSPI_FLASH_CONTROLLER_MEM_MAP_AXI4_BASE_ADDR;
	qspi_core.config_0 = (EN_FRAME_END_DONE_CNTR | EN_FLASH_ADDR_SPACE_MAP | BIG_ENDIAN | DIV_BY_4 | CHIP_SEL_BEH | MIN_IDLE_TIME |
			EN_BACK_TO_BACK_TRANS | SAMPLE_EVEN_EDGES | ACTIVE_HIGH | MSB_FIRST);
	qspi_core.config_1 = TGT_RD_TRANS_CNT;
	qspi_flash_cntl_write(&qspi_core,REG_INT_STATUS, CLR_INTERRUPT);
	qspi_flash_cntl_init(&qspi_core);
	//qspi_flash_cntl_read_write_config_reg(1);
	//qspi_flash_cntl_read_write_config_reg(0);

#if(FLASH_ADDR_MODE == FLASH_ADDR_32BIT) //Enter 4-bytes mode
	qspi_flash_cntl_write(&qspi_core,REG_QSPI_FLASH_CMD_CODE_7, (ENTER_4_BYTE_ADDR_MODE_CMD_CODE | FLASH_CMD_CODE_7_REG_CMD_QUAD_EN));
	qspi_flash_cntl_write(&qspi_core,REG_PACKET_HDR_0, (XFER_LEN_BYTES | NUM_WAIT_STATE | MULT_FLASH_TARGET |
			FLASH_CMD_CODE | WITH_PAYLOAD | SUPPORTED_FLASH_CMD));
	qspi_flash_cntl_write(&qspi_core,REG_PACKET_HDR_1, (FLASH_ADDRESS_WIDTH | TARGET_CS | DATA_LANE_WIDTH |
			ADDRESS_LANE_WIDTH | COMMAND_LANE_WIDTH));
	qspi_flash_cntl_write(&qspi_core,REG_START_TRANS, START_TRANS_VAL);
	qspi_flash_cntl_write(&qspi_core,REG_INT_STATUS, CLR_INTERRUPT);
	qspi_flash_cntl_write(&qspi_core,REG_START_TRANS, CLR_START_TRANS_VAL);
#if(SPI_COMM_MODE == QUAD_SPI_MODE)
	enable_quad_mode();
	qspi_flash_cntl_write(&qspi_core,REG_QSPI_FLASH_CMD_CODE_3, QUAD_IO_FAST_RD_CMD_CODE);
#elif(SPI_COMM_MODE == STANDARD_SPI_MODE)
	qspi_flash_cntl_write(&qspi_core,REG_QSPI_FLASH_CMD_CODE_2, STD_IO_FAST_RD_CMD_CODE); // Fast read opcode
#endif
#elif(FLASH_ADDR_MODE == FLASH_ADDR_24BIT)
	enable_quad_mode();
#endif
}

void mdio_phy_init()
{
	uint32_t access_ctrl_reg = TSE_MAC0_INST_TSE_ETHERNET_MAC_MEM_MAP_BASE_ADDR + 0x20;
	uint32_t access_data_reg = TSE_MAC0_INST_TSE_ETHERNET_MAC_MEM_MAP_BASE_ADDR + 0x24;
	uint8_t reg_addr = 0x3;
	uint8_t phy_reset_reg = 0x0;
	uint16_t phy_reset = 0x0;
	uint16_t data_buffer = 0x0;
	uint16_t reg_write_reset = 0x8140;
	uint32_t phy_id = 0x0;
	uint32_t phy_addr = 0x0;
	uint8_t page_reg_addr = 0x1;
	uint8_t page_num = 0x2;
	uint32_t page_num_read = 0;
	uint32_t copper_status = 0;
	uint32_t gmii_cmd_fin = 0;

	// read the model id
	reg_32b_write(access_ctrl_reg, PHY_REG_READ << PHY_REG_READ_WRITE_SHIFT | phy_addr << PHY_REG_SHIFT | reg_addr);
	while((gmii_cmd_fin & PHY_REG_CMD_FIN) != PHY_REG_CMD_FIN) {
		reg_32b_read(access_ctrl_reg, &gmii_cmd_fin);
	}

	gmii_cmd_fin = 0;
	reg_32b_read(access_data_reg, &phy_id);

	// check for the Marvell PHY model
	uint16_t model = ((phy_id >> 4) & 0x1D);
	printf("\r\nphy_id: %x, model: %x\r\n", phy_id, model);
	if (model == MARVELL_PHY_88E151X) {
		// reset the PHY and set the Full-Duplex mode
		reg_32b_write(access_ctrl_reg, PHY_REG_WRITE << PHY_REG_READ_WRITE_SHIFT | phy_addr << PHY_REG_SHIFT | phy_reset_reg);
		reg_16b_write(access_data_reg, reg_write_reset);

		while((gmii_cmd_fin & 0x00004000) != 0x00004000) {
			reg_32b_read(access_ctrl_reg, &gmii_cmd_fin);
		}

		// read back the control reg.
		gmii_cmd_fin = 0;
		reg_32b_write(access_ctrl_reg, PHY_REG_READ << PHY_REG_READ_WRITE_SHIFT | phy_addr << PHY_REG_SHIFT | phy_reset_reg);

		while((gmii_cmd_fin & 0x00004000) != 0x00004000) {
			reg_32b_read(access_ctrl_reg, &gmii_cmd_fin);
		}

		gmii_cmd_fin = 0;
		reg_16b_read(access_data_reg, &phy_reset);
		printf("\r\nAfter write: Control Register: %x\r\n", phy_reset);

		while((copper_status & 0x24) != 0x24) {
			// read copper status for link-up status
			reg_32b_write(access_ctrl_reg, PHY_REG_READ << PHY_REG_READ_WRITE_SHIFT | phy_addr << PHY_REG_SHIFT | page_reg_addr);
			while((gmii_cmd_fin & 0x00004000) != 0x00004000) {
				reg_32b_read(access_ctrl_reg, &gmii_cmd_fin);
			}

			reg_32b_read(access_data_reg, &copper_status);
		}

		printf("\r\naccess_data_reg - 2, access_data_reg: %x\r\n", copper_status);
	}
	else {
		printf("\r\nSkip write: Not Marvel PHY.\r\n");
	}
}

void fw_softreset(void)
{
	// soft reset command incase crc fails
	reg_32b_write(MBCONFIG0_INST_FPGA_MULTIBOOT_CONFIG_APB_MEM_MAP_BASE_ADDR  , 0x01);
}


int main(void) {
	static uint8_t idx = 0;
	static uint8_t pin_state = 0xFF;
	unsigned int seq =0;
	unsigned int new_addr =GOLDEN_COPY_MEMORY_START_ADDR;
	unsigned int lppdr_addr=LPDDR_APPLICATION_MEMORY_START_ADDR;
	unsigned int crc_calculated = 0;
	unsigned int crc_fw = 0;

	bsp_init();

	//Displaying Welcome Message on UART Terminal
    printf("\r\n****************************************************\r\n");
    printf("***        GSRD Golden Bootloader Avant-E        ***\r\n");
    printf("****************************************************\r\n");


    printf("\r\nMemory Controller Initialization: \r\n");
    LPDDR_init();
    printf("\r\nMemory Controller Initialization Complete.\r\n");
    qspi_init();

	for(seq=0;seq<QSPI_FETCH_SEQ;seq++)
	{
		qspi_flash_cntl_read_fifo_dis(new_addr, FLASH_ADDR_WIDTH, FLASH_CNTL_SPI_MODE,
									  (unsigned int *)lppdr_addr, QSPI_FW_FETCH_SIZE,
									  JEDEC_MANUFACTURER_ID_WINBOND);
		new_addr = new_addr+QSPI_FW_FETCH_SIZE;
		lppdr_addr = lppdr_addr+QSPI_FW_FETCH_SIZE;
	}

    printf("\r\nPHY Initialization: \r\n");
    mdio_phy_init();
    printf("\r\nPHY Initialization Complete.\r\n");

	printf("\r\nMemory Controller Single Write/Read: \r\n");
	crc_calculated = crc16_ccitt((void*)LPDDR_APPLICATION_MEMORY_START_ADDR, LPDDR_APPLICATION_MEMORY_END_ADDR-LPDDR_APPLICATION_MEMORY_START_ADDR, CRC16_START_VAL);
	printf("\n LPDDR crc = %x", crc_calculated);
	reg_32b_read(LPDDR_FW_CRC, &crc_fw);
	crc_fw >>= 16;
	crc_fw = (crc_fw>>8)|((crc_fw <<8)&0xff00);
	printf("\n fw crc = %x", crc_fw);
	reset_quad_mode();

	if(crc_calculated == crc_fw)
	{
		printf("\n--- CRC matches-----------\n");
		asm volatile ("lui	x5, %[appStart]" : : [appStart] "i" (LPDDR_APPLICATION_MEMORY_START_ADDR >> 12));
		asm volatile ("addi x5, x5, %[appStart]" : : [appStart] "i" (LPDDR_APPLICATION_MEMORY_START_ADDR & 0xFFF));
		asm volatile ("jalr x0, x5, 0");
	}
	else
	{
		printf("\n--- CRC Mis-matched!!!-----------\n");
		//fw_softreset();
	}

	while(1);

	return 0;
}

